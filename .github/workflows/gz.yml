name: gz

on:
  push:
    paths:
      - '**/gz.yml'
  workflow_run:
    workflows: ["dump"]
    types:
      - completed
  workflow_dispatch:     # 手动触发  

jobs:
  convert-to-json:
    runs-on: ubuntu-latest
    # 只有当上游 workflow 成功时才运行
    # if: ${{ github.event.workflow_run.conclusion == 'success' }}
    outputs:
      d-length: ${{ steps.d-length.outputs.length }}
      c-length: ${{ steps.c-length.outputs.length }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0   # 确保能 push

      - name: Install MongoDB Server and Tools
        run: |
          wget -qO - https://www.mongodb.org/static/pgp/server-7.0.asc | sudo apt-key add -
          echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/7.0 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-7.0.list
          sudo apt-get update
          sudo apt-get install -y mongodb-org-server mongodb-database-tools

      - name: Install Python and pymongo
        run: |
          sudo apt-get install -y python3-pip
          pip3 install pymongo

      - name: Start temporary MongoDB instance
        run: |
          mkdir -p /tmp/mongodata
          mongod --dbpath /tmp/mongodata --logpath /tmp/mongod.log --fork --quiet

      - name: Determine current month
        id: month
        run: echo "month=$(date +%Y%m)" >> $GITHUB_OUTPUT

      - name: Restore archive directly from .gz
        run: |
          mongorestore --gzip --archive=dump/d${{ steps.month.outputs.month }}.gz \
                       --nsInclude="poi-production.createshiprecords"
          mongorestore --gzip --archive=dump/c${{ steps.month.outputs.month }}.gz \
                       --nsInclude="poi-production.createitemrecords" 

      - name: Export simplified JSON using Python
        run: |
          mkdir -p dump
          python3 - << 'EOF'
          from pymongo import MongoClient
          import json
          from collections import defaultdict

          client = MongoClient('mongodb://localhost:27017/')
          db = client['poi-production']

          # ========== 读取cstype.json ==========
          def load_cstype():
              """加载parsed/cstype.json数据，返回id到dtype的映射字典"""
              try:
                  with open('parsed/cstype.json', 'r', encoding='utf-8') as f:
                      cstype_data = json.load(f)
                  # 构建id->dtype映射（兼容id为整数/字符串）
                  cstype_dict = {}
                  for item in cstype_data:
                      cstype_dict[str(item['id'])] = item.get('dtype', -2)
                  return cstype_dict
              except FileNotFoundError:
                  raise FileNotFoundError("cstype.json not found at parsed/cstype.json")

          cstype_dict = load_cstype()

          def export_processed_mongodb_data(collection, output_file, output_type):
              """
              从MongoDB集合读取数据，按指定逻辑处理后导出为JSON文件
              
              参数:
                  collection: MongoDB集合对象
                  output_file: 输出JSON文件的路径
                  output_type: 字段类型，仅允许"itemId"或"shipId"
              """
              # ========== 校验output_type ==========
              if output_type not in ("itemId", "shipId"):
                  raise ValueError(f"output_type must be 'itemId' or 'shipId', got {output_type}")
              
              # ========== 先收集所有有效记录，用于统计次数和最小等级 ==========
              # 分组维度：items, secretary/dtype, output_type（对应SQL GROUP BY）
              group_key = lambda rec: (
                  json.dumps(rec['items'], ensure_ascii=False),  # items序列化作为分组键
                  rec['secretary_dtype'], 
                  rec['processed_o']
              )
              # 存储分组统计：count(*)和min(teitokuLv)
              group_stats = defaultdict(lambda: {'count': 0, 'min_lv': float('inf')})
              # 存储所有有效记录（跳过secretary=0的）
              valid_records = []
              # 存储异常条目（包含-2的）
              exception_records = []

              # 第一步：查询指定字段，排除_id
              cursor = collection.find({}, {'_id': 0, 'items': 1, output_type: 1, 'teitokuLv': 1, 'successful': 1, 'secretary': 1})
              
              for doc in cursor:
                  # secretary为整数0或字符串"0"的情况
                  secretary_val = doc.get('secretary')
                  if secretary_val in (0, "0"):
                      continue  # 跳过secretary=0的记录，不写入文件
                  
                  # ========== 处理secretary->dtype（对应SQL LEFT JOIN cstype） ==========
                  secretary_dtype = cstype_dict.get(str(secretary_val), -2)
                  
                  # === 对应SQL: UPDATE d2 set itemId=-1 的两个条件 ===
                  field_val = doc.get(output_type)
                  successful_val = doc.get('successful')
                  
                  # 统一转换successful为布尔值（兼容字符串/布尔）
                  if isinstance(successful_val, str):
                      successful_bool = successful_val.lower() == 'true'
                  else:
                      successful_bool = bool(successful_val)
                  
                  # 条件1: successful为false（兼容布尔False或字符串"false"）
                  # 条件2: itemId本身为0（兼容整数0或字符串"0"）
                  if successful_bool is False or field_val in (0, "0"):
                      o = -1
                  else:
                      o = field_val  # 保持原数值
                  
                  # ========== 抛出错误（successful与o值不匹配） ==========
                  if (not successful_bool and o > -1) or (successful_bool and o < 1):
                      raise ValueError(f"Invalid o value: successful={successful_bool}, o={o}, doc={doc}")
                  
                  # ========== 处理ifnull为-2（对应SQL ifnull） ==========
                  # 处理items（排除[null,null,null,null]、空、[]）
                  items = doc.get('items', -2)
                  items_str = json.dumps(items, ensure_ascii=False)
                  if items_str in ('[null,null,null,null]', '', '[]'):
                      items = -2
                  # 处理teitokuLv
                  teitoku_lv = doc.get('teitokuLv', -2)
                  if teitoku_lv == -2:
                      min_lv = -2
                  else:
                      min_lv = int(teitoku_lv) if isinstance(teitoku_lv, (int, str)) else -2
                  # 处理o值（转为-2如果为空）
                  processed_o = o if o is not None else -2
                  
                  # 构造临时记录，用于后续统计
                  temp_rec = {
                      'items': items,
                      'secretary_dtype': secretary_dtype,
                      'processed_o': processed_o,
                      'teitoku_lv': min_lv,
                      'successful_bool': successful_bool
                  }
                  valid_records.append(temp_rec)
                  
                  # ========== 统计分组计数和最小等级 ==========
                  key = group_key(temp_rec)
                  group_stats[key]['count'] += 1
                  if min_lv != -2 and min_lv < group_stats[key]['min_lv']:
                      group_stats[key]['min_lv'] = min_lv

              # ========== 第二步：处理分组统计，替换为最终值（-2兜底） ==========
              final_records = []
              for rec in valid_records:
                  key = group_key(rec)
                  # 获取count（-2兜底）
                  n = group_stats[key]['count'] if group_stats[key]['count'] > 0 else -2
                  # 获取min_lv（-2兜底）
                  l = group_stats[key]['min_lv'] if group_stats[key]['min_lv'] != float('inf') else -2
                  
                  # 构造简化后的记录（对应SQL字段：i, s, o, n, l）
                  simplified = [
                      rec['items'],          # i: ifnull(items,-2)
                      rec['secretary_dtype'],# s: ifnull(b.dtype/secretary,-2)
                      rec['processed_o'],    # o: ifnull(itemId/shipId,-2)
                      n,                     # n: ifnull(count(*),-2) 替换原successful的0/1
                      l                      # l: ifnull(min(teitokuLv),-2)
                  ]
                  final_records.append(simplified)
                  
                  # ========== 收集异常条目（包含-2） ==========
                  if -2 in simplified:
                      exception_records.append(simplified)

              # ========== 写入JSON文件（保持原有格式） ==========
              first = True
              with open(output_file, 'w', encoding='utf-8') as f:
                  f.write('{"RECORDS": [')
                  for simplified in final_records:
                      if not first:
                          f.write(',')
                      f.write(json.dumps(simplified, ensure_ascii=False))
                      first = False
                  f.write(']}')

              # ========== 打印异常条目（包含-2） ==========
              print(f"\n异常条目（包含-2）总数: {len(exception_records)}")
              if exception_records:
                  print("异常条目详情:")
                  for idx, exc_rec in enumerate(exception_records[:100]):  # 仅打印前100条避免刷屏
                      print(f"  条目{idx+1}: {exc_rec}")
                  if len(exception_records) > 100:
                      print(f"  ... 省略{len(exception_records)-100}条异常条目")

              print(f"处理后的JSON已导出到 {output_file}")

          # ========== 修改：调用函数时传入output_type ==========
          collection = db['createitemrecords']
          export_processed_mongodb_data(collection, f"dump/d${{ steps.month.outputs.month }}.json", "itemId")
          collection = db['createshiprecords']
          export_processed_mongodb_data(collection, f"dump/c${{ steps.month.outputs.month }}.json", "shipId")
          EOF

      - name: Show result size
        run: |
          echo "Simplified JSON file generated:"
          ls -lh dump/d${{ steps.month.outputs.month }}.json
          echo "Line count (approx records + 2): $(wc < dump/d${{ steps.month.outputs.month }}.json)"
          ls -lh dump/c${{ steps.month.outputs.month }}.json
          echo "Line count (approx records + 2): $(wc < dump/c${{ steps.month.outputs.month }}.json)"

      # 调用自定义的可复用Action
      - name: Check JSON array length in develop
        id: d-length
        uses: ./.github/actions/check-json-length
        with:
          json-file-path: "dump/d${{ steps.month.outputs.month }}.json"  # 改为本地parsed目录
          output-var-name: "D_LENGTH"

      # 调用自定义的可复用Action
      - name: Check JSON array length in construction
        id: c-length
        uses: ./.github/actions/check-json-length
        with:
          json-file-path: "dump/c${{ steps.month.outputs.month }}.json"  # 改为本地parsed目录
          output-var-name: "C_LENGTH"
          
      - name: 取消工作流（LENGTH=0）
        if: steps.d-length.outputs.length == 0
        uses: conbanwa/cancel-workflow/.github/actions/cancel-workflow@v1.0.0
        with:
          cancel-reason: 'MD5 无变化（c/d 均一致），无需提交，自动取消工作流'

      - name: Commit and push pure JSON (overwrite monthly file)
        run: |
          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"
          git add dump/
          git commit -m "Update monthly pure JSON: ${{ steps.month.outputs.month }}.json" || echo "No changes to commit"
          git push

      - name: Cleanup temporary MongoDB
        if: always()
        run: |
          mongo admin --eval "db.shutdownServer({force:true})" || true
          rm -rf /tmp/mongodata /tmp/mongod.log
